// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * @title BancafiSavingsAccount
 * @notice Simple blockchain savings account with fixed APY (4.5% - 7%)
 * @dev Traditional savings account features on blockchain
 */
contract BancafiSavingsAccount is
    Initializable,
    ReentrancyGuardUpgradeable,
    PausableUpgradeable,
    OwnableUpgradeable
{
    using SafeERC20 for IERC20;

    struct SavingsAccount {
        uint256 balance;
        uint256 lastInterestUpdate;
        uint256 totalInterestEarned;
        uint256 accountOpenDate;
        bool isActive;
    }

    // State variables
    mapping(address => mapping(address => SavingsAccount)) public accounts; // user => token => Account
    mapping(address => bool) public supportedTokens;

    uint256 public baseAPY;           // Base APY: 4.5% = 450 (in basis points)
    uint256 public bonusAPY;          // Bonus APY: up to 2.5% = 250
    uint256 public bonusThreshold;    // Time threshold for bonus (e.g., 90 days)

    uint256 public constant BPS_DENOMINATOR = 10000;
    uint256 public constant SECONDS_PER_YEAR = 365 days;
    uint256 public constant MIN_DEPOSIT = 10 * 10**18; // 10 tokens minimum

    uint256 public totalDeposits;
    uint256 public totalInterestPaid;
    uint256 public totalAccounts;

    // Events
    event AccountOpened(address indexed user, address indexed token, uint256 timestamp);
    event Deposit(address indexed user, address indexed token, uint256 amount, uint256 newBalance);
    event Withdrawal(address indexed user, address indexed token, uint256 amount, uint256 remainingBalance);
    event InterestPaid(address indexed user, address indexed token, uint256 interestAmount, uint256 newBalance);
    event TokenAdded(address indexed token);
    event TokenRemoved(address indexed token);
    event APYUpdated(uint256 newBaseAPY, uint256 newBonusAPY);

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /**
     * @notice Initialize the savings account contract
     * @param _baseAPY Base APY in basis points (450 = 4.5%)
     * @param _bonusAPY Bonus APY in basis points (250 = 2.5%)
     * @param _bonusThreshold Time threshold for bonus in seconds
     */
    function initialize(
        uint256 _baseAPY,
        uint256 _bonusAPY,
        uint256 _bonusThreshold
    ) public initializer {
        require(_baseAPY >= 450 && _baseAPY <= 700, "Base APY must be between 4.5% and 7%");
        require(_bonusAPY <= 250, "Bonus APY cannot exceed 2.5%");

        __ReentrancyGuard_init();
        __Pausable_init();
        __Ownable_init(msg.sender);

        baseAPY = _baseAPY;
        bonusAPY = _bonusAPY;
        bonusThreshold = _bonusThreshold;
    }

    /**
     * @notice Add a supported token
     * @param token Address of the token to support
     */
    function addSupportedToken(address token) external onlyOwner {
        require(token != address(0), "Invalid token address");
        require(!supportedTokens[token], "Token already supported");

        supportedTokens[token] = true;
        emit TokenAdded(token);
    }

    /**
     * @notice Remove a supported token
     * @param token Address of the token to remove
     */
    function removeSupportedToken(address token) external onlyOwner {
        require(supportedTokens[token], "Token not supported");

        supportedTokens[token] = false;
        emit TokenRemoved(token);
    }

    /**
     * @notice Deposit tokens into savings account
     * @param token Address of the token to deposit
     * @param amount Amount to deposit
     */
    function deposit(address token, uint256 amount) external nonReentrant whenNotPaused {
        require(supportedTokens[token], "Token not supported");
        require(amount >= MIN_DEPOSIT, "Amount below minimum deposit");

        SavingsAccount storage account = accounts[msg.sender][token];

        // If account exists, calculate and add accrued interest first
        if (account.isActive) {
            _accrueInterest(msg.sender, token);
        } else {
            // Open new account
            account.isActive = true;
            account.accountOpenDate = block.timestamp;
            account.lastInterestUpdate = block.timestamp;
            totalAccounts++;
            emit AccountOpened(msg.sender, token, block.timestamp);
        }

        // Transfer tokens from user
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);

        // Update account balance
        account.balance += amount;
        totalDeposits += amount;

        emit Deposit(msg.sender, token, amount, account.balance);
    }

    /**
     * @notice Withdraw tokens from savings account
     * @param token Address of the token to withdraw
     * @param amount Amount to withdraw (0 = withdraw all)
     */
    function withdraw(address token, uint256 amount) external nonReentrant whenNotPaused {
        SavingsAccount storage account = accounts[msg.sender][token];
        require(account.isActive, "No active account");
        require(account.balance > 0, "Insufficient balance");

        // Accrue interest before withdrawal
        _accrueInterest(msg.sender, token);

        // If amount is 0, withdraw everything
        if (amount == 0) {
            amount = account.balance;
        }

        require(amount <= account.balance, "Insufficient balance");

        // Update balance
        account.balance -= amount;
        totalDeposits -= amount;

        // Close account if balance is zero
        if (account.balance == 0) {
            account.isActive = false;
        }

        // Transfer tokens to user
        IERC20(token).safeTransfer(msg.sender, amount);

        emit Withdrawal(msg.sender, token, amount, account.balance);
    }

    /**
     * @notice Accrue interest for an account
     * @param user Address of the user
     * @param token Address of the token
     */
    function _accrueInterest(address user, address token) internal {
        SavingsAccount storage account = accounts[user][token];

        if (!account.isActive || account.balance == 0) {
            return;
        }

        uint256 interest = calculateInterest(user, token);

        if (interest > 0) {
            account.balance += interest;
            account.totalInterestEarned += interest;
            account.lastInterestUpdate = block.timestamp;
            totalInterestPaid += interest;

            emit InterestPaid(user, token, interest, account.balance);
        }
    }

    /**
     * @notice Claim accrued interest without withdrawing principal
     * @param token Address of the token
     */
    function claimInterest(address token) external nonReentrant whenNotPaused {
        SavingsAccount storage account = accounts[msg.sender][token];
        require(account.isActive, "No active account");

        _accrueInterest(msg.sender, token);
    }

    /**
     * @notice Calculate interest earned for an account
     * @param user Address of the user
     * @param token Address of the token
     * @return Interest amount
     */
    function calculateInterest(address user, address token) public view returns (uint256) {
        SavingsAccount memory account = accounts[user][token];

        if (!account.isActive || account.balance == 0) {
            return 0;
        }

        uint256 timeElapsed = block.timestamp - account.lastInterestUpdate;
        uint256 effectiveAPY = getEffectiveAPY(user, token);

        // Interest = (balance * APY * time) / (BPS_DENOMINATOR * SECONDS_PER_YEAR)
        uint256 interest = (account.balance * effectiveAPY * timeElapsed) /
                          (BPS_DENOMINATOR * SECONDS_PER_YEAR);

        return interest;
    }

    /**
     * @notice Get effective APY for an account (base + bonus if eligible)
     * @param user Address of the user
     * @param token Address of the token
     * @return Effective APY in basis points
     */
    function getEffectiveAPY(address user, address token) public view returns (uint256) {
        SavingsAccount memory account = accounts[user][token];

        if (!account.isActive) {
            return baseAPY;
        }

        // Check if account qualifies for bonus APY
        uint256 accountAge = block.timestamp - account.accountOpenDate;

        if (accountAge >= bonusThreshold) {
            return baseAPY + bonusAPY; // Up to 7%
        }

        return baseAPY; // Base 4.5%
    }

    /**
     * @notice Get account information
     * @param user Address of the user
     * @param token Address of the token
     * @return balance Current balance
     * @return totalInterestEarned Total interest earned
     * @return currentAPY Current APY rate
     * @return pendingInterest Pending interest to be claimed
     * @return accountAge Age of account in seconds
     * @return isActive Whether account is active
     */
    function getAccountInfo(address user, address token)
        external
        view
        returns (
            uint256 balance,
            uint256 totalInterestEarned,
            uint256 currentAPY,
            uint256 pendingInterest,
            uint256 accountAge,
            bool isActive
        )
    {
        SavingsAccount memory account = accounts[user][token];

        return (
            account.balance,
            account.totalInterestEarned,
            getEffectiveAPY(user, token),
            calculateInterest(user, token),
            account.isActive ? block.timestamp - account.accountOpenDate : 0,
            account.isActive
        );
    }

    /**
     * @notice Update APY rates
     * @param newBaseAPY New base APY in basis points
     * @param newBonusAPY New bonus APY in basis points
     */
    function updateAPY(uint256 newBaseAPY, uint256 newBonusAPY) external onlyOwner {
        require(newBaseAPY >= 450 && newBaseAPY <= 700, "Base APY must be between 4.5% and 7%");
        require(newBonusAPY <= 250, "Bonus APY cannot exceed 2.5%");
        require(newBaseAPY + newBonusAPY <= 700, "Total APY cannot exceed 7%");

        baseAPY = newBaseAPY;
        bonusAPY = newBonusAPY;

        emit APYUpdated(newBaseAPY, newBonusAPY);
    }

    /**
     * @notice Update bonus threshold
     * @param newThreshold New threshold in seconds
     */
    function updateBonusThreshold(uint256 newThreshold) external onlyOwner {
        bonusThreshold = newThreshold;
    }

    /**
     * @notice Get contract statistics
     * @return totalDeposits_ Total amount deposited
     * @return totalInterestPaid_ Total interest paid out
     * @return totalAccounts_ Total number of accounts opened
     */
    function getContractStats()
        external
        view
        returns (
            uint256 totalDeposits_,
            uint256 totalInterestPaid_,
            uint256 totalAccounts_
        )
    {
        return (totalDeposits, totalInterestPaid, totalAccounts);
    }

    /**
     * @notice Fund the contract with tokens for interest payments
     * @param token Address of the token
     * @param amount Amount to fund
     */
    function fundContract(address token, uint256 amount) external onlyOwner {
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
    }

    /**
     * @notice Withdraw excess funds (owner only, for managing liquidity)
     * @param token Address of the token
     * @param amount Amount to withdraw
     */
    function withdrawExcess(address token, uint256 amount) external onlyOwner {
        uint256 contractBalance = IERC20(token).balanceOf(address(this));
        require(contractBalance >= totalDeposits + amount, "Cannot withdraw user deposits");

        IERC20(token).safeTransfer(msg.sender, amount);
    }

    /**
     * @notice Pause the contract
     */
    function pause() external onlyOwner {
        _pause();
    }

    /**
     * @notice Unpause the contract
     */
    function unpause() external onlyOwner {
        _unpause();
    }
}
