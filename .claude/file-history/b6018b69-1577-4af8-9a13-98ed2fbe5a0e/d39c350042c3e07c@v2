const { expect } = require("chai");
const { ethers, upgrades } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("BancafiSavingsAccount", function () {
  let savingsAccount;
  let token;
  let owner;
  let user1;
  let user2;

  const BASE_APY = 450; // 4.5%
  const BONUS_APY = 250; // 2.5%
  const BONUS_THRESHOLD = 90 * 24 * 60 * 60; // 90 days
  const MIN_DEPOSIT = ethers.parseEther("10");

  beforeEach(async function () {
    // Get signers
    [owner, user1, user2] = await ethers.getSigners();

    // Deploy mock ERC20 token
    const MockERC20 = await ethers.getContractFactory("MockERC20");
    token = await MockERC20.deploy("Test Token", "TEST", ethers.parseEther("1000000"));
    await token.waitForDeployment();

    // Deploy BancafiSavingsAccount
    const BancafiSavingsAccount = await ethers.getContractFactory("BancafiSavingsAccount");
    savingsAccount = await upgrades.deployProxy(
      BancafiSavingsAccount,
      [BASE_APY, BONUS_APY, BONUS_THRESHOLD],
      { initializer: "initialize" }
    );
    await savingsAccount.waitForDeployment();

    // Add token as supported
    await savingsAccount.addSupportedToken(await token.getAddress());

    // Fund contract for interest payments
    const fundAmount = ethers.parseEther("100000");
    await token.approve(await savingsAccount.getAddress(), fundAmount);
    await savingsAccount.fundContract(await token.getAddress(), fundAmount);

    // Transfer tokens to users
    await token.transfer(user1.address, ethers.parseEther("10000"));
    await token.transfer(user2.address, ethers.parseEther("10000"));
  });

  describe("Deployment", function () {
    it("Should set the correct APY values", async function () {
      expect(await savingsAccount.baseAPY()).to.equal(BASE_APY);
      expect(await savingsAccount.bonusAPY()).to.equal(BONUS_APY);
      expect(await savingsAccount.bonusThreshold()).to.equal(BONUS_THRESHOLD);
    });

    it("Should set the correct owner", async function () {
      expect(await savingsAccount.owner()).to.equal(owner.address);
    });

    it("Should have token marked as supported", async function () {
      expect(await savingsAccount.supportedTokens(await token.getAddress())).to.be.true;
    });
  });

  describe("Token Management", function () {
    it("Should allow owner to add supported tokens", async function () {
      const MockERC20 = await ethers.getContractFactory("MockERC20");
      const newToken = await MockERC20.deploy("New Token", "NEW", ethers.parseEther("1000000"));
      await newToken.waitForDeployment();

      await expect(savingsAccount.addSupportedToken(await newToken.getAddress()))
        .to.emit(savingsAccount, "TokenAdded")
        .withArgs(await newToken.getAddress());

      expect(await savingsAccount.supportedTokens(await newToken.getAddress())).to.be.true;
    });

    it("Should not allow non-owner to add tokens", async function () {
      const MockERC20 = await ethers.getContractFactory("MockERC20");
      const newToken = await MockERC20.deploy("New Token", "NEW", ethers.parseEther("1000000"));
      await newToken.waitForDeployment();

      await expect(
        savingsAccount.connect(user1).addSupportedToken(await newToken.getAddress())
      ).to.be.reverted;
    });

    it("Should not allow duplicate token additions", async function () {
      await expect(
        savingsAccount.addSupportedToken(await token.getAddress())
      ).to.be.revertedWith("Token already supported");
    });
  });

  describe("Deposits", function () {
    it("Should allow users to deposit tokens", async function () {
      const depositAmount = ethers.parseEther("100");

      await token.connect(user1).approve(await savingsAccount.getAddress(), depositAmount);

      await expect(
        savingsAccount.connect(user1).deposit(await token.getAddress(), depositAmount)
      )
        .to.emit(savingsAccount, "AccountOpened")
        .to.emit(savingsAccount, "Deposit")
        .withArgs(user1.address, await token.getAddress(), depositAmount, depositAmount);

      const accountInfo = await savingsAccount.getAccountInfo(user1.address, await token.getAddress());
      expect(accountInfo.balance).to.equal(depositAmount);
      expect(accountInfo.isActive).to.be.true;
    });

    it("Should reject deposits below minimum", async function () {
      const depositAmount = ethers.parseEther("5"); // Below MIN_DEPOSIT

      await token.connect(user1).approve(await savingsAccount.getAddress(), depositAmount);

      await expect(
        savingsAccount.connect(user1).deposit(await token.getAddress(), depositAmount)
      ).to.be.revertedWith("Amount below minimum deposit");
    });

    it("Should reject deposits of unsupported tokens", async function () {
      const MockERC20 = await ethers.getContractFactory("MockERC20");
      const unsupportedToken = await MockERC20.deploy("Unsupported", "UNS", ethers.parseEther("1000"));
      await unsupportedToken.waitForDeployment();

      const depositAmount = ethers.parseEther("100");
      await unsupportedToken.connect(user1).approve(await savingsAccount.getAddress(), depositAmount);

      await expect(
        savingsAccount.connect(user1).deposit(await unsupportedToken.getAddress(), depositAmount)
      ).to.be.revertedWith("Token not supported");
    });

    it("Should allow multiple deposits to same account", async function () {
      const depositAmount = ethers.parseEther("100");

      await token.connect(user1).approve(await savingsAccount.getAddress(), depositAmount * 2n);

      await savingsAccount.connect(user1).deposit(await token.getAddress(), depositAmount);
      await savingsAccount.connect(user1).deposit(await token.getAddress(), depositAmount);

      const accountInfo = await savingsAccount.getAccountInfo(user1.address, await token.getAddress());
      expect(accountInfo.balance).to.be.gte(depositAmount * 2n); // >= because of accrued interest
    });
  });

  describe("Interest Calculation", function () {
    it("Should calculate interest correctly with base APY", async function () {
      const depositAmount = ethers.parseEther("1000");

      await token.connect(user1).approve(await savingsAccount.getAddress(), depositAmount);
      await savingsAccount.connect(user1).deposit(await token.getAddress(), depositAmount);

      // Advance time by 1 year
      await time.increase(365 * 24 * 60 * 60);

      const interest = await savingsAccount.calculateInterest(user1.address, await token.getAddress());

      // Expected interest: 1000 * 4.5% = 45
      const expectedInterest = ethers.parseEther("45");
      expect(interest).to.be.closeTo(expectedInterest, ethers.parseEther("0.1"));
    });

    it("Should apply bonus APY after threshold", async function () {
      const depositAmount = ethers.parseEther("1000");

      await token.connect(user1).approve(await savingsAccount.getAddress(), depositAmount);
      await savingsAccount.connect(user1).deposit(await token.getAddress(), depositAmount);

      // Advance time past bonus threshold (90 days)
      await time.increase(BONUS_THRESHOLD);

      const effectiveAPY = await savingsAccount.getEffectiveAPY(user1.address, await token.getAddress());
      expect(effectiveAPY).to.equal(BASE_APY + BONUS_APY); // 7%

      // Advance another year
      await time.increase(365 * 24 * 60 * 60);

      const interest = await savingsAccount.calculateInterest(user1.address, await token.getAddress());

      // Expected interest: 1000 * 7% = 70 (approximately)
      const expectedInterest = ethers.parseEther("70");
      expect(interest).to.be.closeTo(expectedInterest, ethers.parseEther("5"));
    });

    it("Should accrue interest on claim", async function () {
      const depositAmount = ethers.parseEther("1000");

      await token.connect(user1).approve(await savingsAccount.getAddress(), depositAmount);
      await savingsAccount.connect(user1).deposit(await token.getAddress(), depositAmount);

      // Advance time
      await time.increase(30 * 24 * 60 * 60); // 30 days

      await expect(
        savingsAccount.connect(user1).claimInterest(await token.getAddress())
      ).to.emit(savingsAccount, "InterestPaid");

      const accountInfo = await savingsAccount.getAccountInfo(user1.address, await token.getAddress());
      expect(accountInfo.balance).to.be.gt(depositAmount);
      expect(accountInfo.totalInterestEarned).to.be.gt(0);
    });
  });

  describe("Withdrawals", function () {
    beforeEach(async function () {
      const depositAmount = ethers.parseEther("1000");
      await token.connect(user1).approve(await savingsAccount.getAddress(), depositAmount);
      await savingsAccount.connect(user1).deposit(await token.getAddress(), depositAmount);
    });

    it("Should allow partial withdrawals", async function () {
      const withdrawAmount = ethers.parseEther("500");

      await expect(
        savingsAccount.connect(user1).withdraw(await token.getAddress(), withdrawAmount)
      )
        .to.emit(savingsAccount, "Withdrawal")
        .withArgs(user1.address, await token.getAddress(), withdrawAmount, ethers.parseEther("500"));

      const accountInfo = await savingsAccount.getAccountInfo(user1.address, await token.getAddress());
      expect(accountInfo.balance).to.equal(ethers.parseEther("500"));
      expect(accountInfo.isActive).to.be.true;
    });

    it("Should allow full withdrawals", async function () {
      await savingsAccount.connect(user1).withdraw(await token.getAddress(), 0); // 0 = withdraw all

      const accountInfo = await savingsAccount.getAccountInfo(user1.address, await token.getAddress());
      expect(accountInfo.balance).to.equal(0);
      expect(accountInfo.isActive).to.be.false;
    });

    it("Should accrue interest before withdrawal", async function () {
      // Advance time
      await time.increase(365 * 24 * 60 * 60); // 1 year

      const balanceBefore = await token.balanceOf(user1.address);

      await savingsAccount.connect(user1).withdraw(await token.getAddress(), 0);

      const balanceAfter = await token.balanceOf(user1.address);
      const gained = balanceAfter - balanceBefore;

      // Should receive principal + interest
      expect(gained).to.be.gt(ethers.parseEther("1000"));
    });

    it("Should reject withdrawals exceeding balance", async function () {
      const withdrawAmount = ethers.parseEther("2000");

      await expect(
        savingsAccount.connect(user1).withdraw(await token.getAddress(), withdrawAmount)
      ).to.be.revertedWith("Insufficient balance");
    });

    it("Should reject withdrawals from non-existent accounts", async function () {
      await expect(
        savingsAccount.connect(user2).withdraw(await token.getAddress(), ethers.parseEther("100"))
      ).to.be.revertedWith("No active account");
    });
  });

  describe("APY Updates", function () {
    it("Should allow owner to update APY", async function () {
      const newBaseAPY = 500; // 5%
      const newBonusAPY = 200; // 2%

      await expect(savingsAccount.updateAPY(newBaseAPY, newBonusAPY))
        .to.emit(savingsAccount, "APYUpdated")
        .withArgs(newBaseAPY, newBonusAPY);

      expect(await savingsAccount.baseAPY()).to.equal(newBaseAPY);
      expect(await savingsAccount.bonusAPY()).to.equal(newBonusAPY);
    });

    it("Should not allow APY above maximum", async function () {
      await expect(
        savingsAccount.updateAPY(800, 0) // 8% > 7% max
      ).to.be.revertedWith("Base APY must be between 4.5% and 7%");
    });

    it("Should not allow total APY exceeding 7%", async function () {
      await expect(
        savingsAccount.updateAPY(500, 300) // 5% + 3% = 8%
      ).to.be.revertedWith("Total APY cannot exceed 7%");
    });

    it("Should not allow non-owner to update APY", async function () {
      await expect(
        savingsAccount.connect(user1).updateAPY(500, 200)
      ).to.be.reverted;
    });
  });

  describe("Contract Statistics", function () {
    it("Should track total deposits", async function () {
      const depositAmount = ethers.parseEther("1000");

      await token.connect(user1).approve(await savingsAccount.getAddress(), depositAmount);
      await savingsAccount.connect(user1).deposit(await token.getAddress(), depositAmount);

      const stats = await savingsAccount.getContractStats();
      expect(stats.totalDeposits_).to.equal(depositAmount);
    });

    it("Should track total accounts", async function () {
      const depositAmount = ethers.parseEther("1000");

      await token.connect(user1).approve(await savingsAccount.getAddress(), depositAmount);
      await savingsAccount.connect(user1).deposit(await token.getAddress(), depositAmount);

      await token.connect(user2).approve(await savingsAccount.getAddress(), depositAmount);
      await savingsAccount.connect(user2).deposit(await token.getAddress(), depositAmount);

      const stats = await savingsAccount.getContractStats();
      expect(stats.totalAccounts_).to.equal(2);
    });
  });

  describe("Pause Functionality", function () {
    it("Should allow owner to pause contract", async function () {
      await savingsAccount.pause();
      expect(await savingsAccount.paused()).to.be.true;
    });

    it("Should prevent deposits when paused", async function () {
      await savingsAccount.pause();

      const depositAmount = ethers.parseEther("100");
      await token.connect(user1).approve(await savingsAccount.getAddress(), depositAmount);

      await expect(
        savingsAccount.connect(user1).deposit(await token.getAddress(), depositAmount)
      ).to.be.reverted;
    });

    it("Should allow owner to unpause", async function () {
      await savingsAccount.pause();
      await savingsAccount.unpause();

      expect(await savingsAccount.paused()).to.be.false;
    });
  });
});

// Mock ERC20 contract for testing
