// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

import "./libraries/Errors.sol";
import "./libraries/Events.sol";

/**
 * @title BancafiToken
 * @notice Governance token for Bancafi DAO with voting capabilities
 * @dev ERC20 token with votes extension for on-chain governance
 */
contract BancafiToken is
    Initializable,
    ERC20Upgradeable,
    ERC20BurnableUpgradeable,
    ERC20VotesUpgradeable,
    AccessControlUpgradeable,
    PausableUpgradeable,
    UUPSUpgradeable
{
    // ============ Roles ============
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");

    // ============ State Variables ============
    uint256 public constant MAX_SUPPLY = 1_000_000_000 * 10**18; // 1 billion tokens

    // Token distribution tracking
    uint256 public communityAllocation;
    uint256 public teamAllocation;
    uint256 public treasuryAllocation;
    uint256 public ecosystemAllocation;

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /**
     * @notice Initialize the token
     * @param admin_ Admin address
     * @param initialSupply Initial supply to mint
     */
    function initialize(
        address admin_,
        uint256 initialSupply
    ) public initializer {
        if (admin_ == address(0)) revert Errors.ZeroAddress();
        if (initialSupply > MAX_SUPPLY) revert Errors.InvalidParameter();

        __ERC20_init("Bancafi Token", "BAFI");
        __ERC20Burnable_init();
        __ERC20Permit_init("Bancafi Token");
        __ERC20Votes_init();
        __AccessControl_init();
        __Pausable_init();
        __UUPSUpgradeable_init();

        _grantRole(DEFAULT_ADMIN_ROLE, admin_);
        _grantRole(ADMIN_ROLE, admin_);
        _grantRole(MINTER_ROLE, admin_);
        _grantRole(UPGRADER_ROLE, admin_);

        // Mint initial supply to admin
        if (initialSupply > 0) {
            _mint(admin_, initialSupply);
        }

        // Set allocations (50% community, 20% team, 20% treasury, 10% ecosystem)
        communityAllocation = (MAX_SUPPLY * 50) / 100;
        teamAllocation = (MAX_SUPPLY * 20) / 100;
        treasuryAllocation = (MAX_SUPPLY * 20) / 100;
        ecosystemAllocation = (MAX_SUPPLY * 10) / 100;
    }

    /**
     * @notice Mint new tokens
     * @param to Recipient address
     * @param amount Amount to mint
     */
    function mint(address to, uint256 amount)
        external
        onlyRole(MINTER_ROLE)
        whenNotPaused
    {
        if (to == address(0)) revert Errors.ZeroAddress();
        if (totalSupply() + amount > MAX_SUPPLY) revert Errors.InvalidParameter();

        _mint(to, amount);
    }

    /**
     * @notice Batch mint tokens to multiple addresses
     * @param recipients Array of recipient addresses
     * @param amounts Array of amounts
     */
    function batchMint(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external onlyRole(MINTER_ROLE) whenNotPaused {
        if (recipients.length != amounts.length) revert Errors.ArrayLengthMismatch();
        if (recipients.length == 0) revert Errors.InvalidArrayLength();

        uint256 totalAmount = 0;
        for (uint256 i = 0; i < amounts.length; i++) {
            totalAmount += amounts[i];
        }

        if (totalSupply() + totalAmount > MAX_SUPPLY) revert Errors.InvalidParameter();

        for (uint256 i = 0; i < recipients.length; i++) {
            if (recipients[i] == address(0)) revert Errors.ZeroAddress();
            _mint(recipients[i], amounts[i]);
        }
    }

    /**
     * @notice Delegate voting power to another address
     * @param delegatee Address to delegate to
     */
    function delegateVotes(address delegatee) external {
        delegate(delegatee);
    }

    /**
     * @notice Pause token transfers
     */
    function pause() external onlyRole(ADMIN_ROLE) {
        _pause();
        emit Events.ContractPaused(msg.sender, block.timestamp);
    }

    /**
     * @notice Unpause token transfers
     */
    function unpause() external onlyRole(ADMIN_ROLE) {
        _unpause();
        emit Events.ContractUnpaused(msg.sender, block.timestamp);
    }

    // ============ Override Functions ============

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override whenNotPaused {
        super._beforeTokenTransfer(from, to, amount);
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {
        super._afterTokenTransfer(from, to, amount);
    }

    function _mint(address to, uint256 amount)
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._mint(to, amount);
    }

    function _burn(address account, uint256 amount)
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._burn(account, amount);
    }

    function nonces(address owner)
        public
        view
        override(ERC20PermitUpgradeable)
        returns (uint256)
    {
        return super.nonces(owner);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(AccessControlUpgradeable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    function _authorizeUpgrade(address newImplementation)
        internal
        override
        onlyRole(UPGRADER_ROLE)
    {}
}
