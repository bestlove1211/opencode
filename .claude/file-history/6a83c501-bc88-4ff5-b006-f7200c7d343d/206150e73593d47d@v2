import { expect, ethers } from "./helpers/setup.js";
import {
    deployFullSystem,
    createDebtMetadata,
    createRepaymentSchedule,
    setupKYC,
    mintDebtToken,
    increaseTime,
    getCurrentTimestamp
} from "./helpers/setup.js";

describe("CollectionAutomator", function () {
    let system, collectionAutomator, debtToken, reputationManager, marketplace;
    let admin, operator, user1, user2, user3;
    let tokenId;

    beforeEach(async function () {
        system = await deployFullSystem();
        ({
            collectionAutomator,
            debtToken,
            reputationManager,
            marketplace,
            admin,
            operator,
            user1,
            user2,
            user3
        } = system);

        // Setup KYC
        await setupKYC(system.complianceManager, user1, 2);
        await setupKYC(system.complianceManager, user2, 2);
        await setupKYC(system.complianceManager, user3, 2);

        // Mint test debt token
        const metadata = createDebtMetadata();
        const schedule = createRepaymentSchedule();
        tokenId = await mintDebtToken(debtToken, user1.address, user2.address, metadata, schedule, []);
    });

    describe("Initialization", function () {
        it("Should set correct contract addresses", async function () {
            expect(await collectionAutomator.debtToken()).to.equal(await debtToken.getAddress());
            expect(await collectionAutomator.reputationManager()).to.equal(await reputationManager.getAddress());
            expect(await collectionAutomator.marketplace()).to.equal(await marketplace.getAddress());
        });

        it("Should set default parameters", async function () {
            expect(await collectionAutomator.defaultSecurityDepositAmount()).to.equal(ethers.parseEther("1000"));
            expect(await collectionAutomator.slashingPercentage()).to.equal(2000); // 20%
            expect(await collectionAutomator.maxWarningsBeforeDefault()).to.equal(3);
        });

        it("Should grant admin role", async function () {
            const ADMIN_ROLE = await collectionAutomator.ADMIN_ROLE();
            expect(await collectionAutomator.hasRole(ADMIN_ROLE, admin.address)).to.be.true;
        });
    });

    describe("Security Deposits", function () {
        it("Should deposit security amount", async function () {
            const amount = ethers.parseEther("1000");
            await expect(
                collectionAutomator.connect(user2).depositSecurity({ value: amount })
            ).to.emit(collectionAutomator, "SecurityDeposited")
              .withArgs(user2.address, amount);
        });

        it("Should track deposited amounts", async function () {
            const amount = ethers.parseEther("1000");
            await collectionAutomator.connect(user2).depositSecurity({ value: amount });

            expect(await collectionAutomator.getSecurityDeposit(user2.address)).to.equal(amount);
        });

        it("Should allow multiple deposits", async function () {
            await collectionAutomator.connect(user2).depositSecurity({ value: ethers.parseEther("500") });
            await collectionAutomator.connect(user2).depositSecurity({ value: ethers.parseEther("500") });

            expect(await collectionAutomator.getSecurityDeposit(user2.address)).to.equal(ethers.parseEther("1000"));
        });

        it("Should withdraw security deposit", async function () {
            const amount = ethers.parseEther("1000");
            await collectionAutomator.connect(user2).depositSecurity({ value: amount });

            const balanceBefore = await ethers.provider.getBalance(user2.address);
            await collectionAutomator.connect(user2).withdrawSecurity(amount);
            const balanceAfter = await ethers.provider.getBalance(user2.address);

            expect(balanceAfter).to.be.gt(balanceBefore);
        });

        it("Should revert if withdrawing more than deposited", async function () {
            await collectionAutomator.connect(user2).depositSecurity({ value: ethers.parseEther("500") });

            await expect(
                collectionAutomator.connect(user2).withdrawSecurity(ethers.parseEther("1000"))
            ).to.be.reverted;
        });

        it("Should revert withdraw if has active debts", async function () {
            await collectionAutomator.connect(user2).depositSecurity({ value: ethers.parseEther("1000") });

            // Mark as having active debt (would be done through payment monitoring)
            await expect(
                collectionAutomator.connect(user2).withdrawSecurity(ethers.parseEther("500"))
            ).to.be.reverted;
        });
    });

    describe("Payment Monitoring", function () {
        it("Should schedule next payment date", async function () {
            const nextPayment = Math.floor(Date.now() / 1000) + 2592000; // 30 days
            await collectionAutomator.schedulePayment(tokenId, nextPayment);

            expect(await collectionAutomator.getNextPaymentDue(tokenId)).to.equal(nextPayment);
        });

        it("Should detect missed payment", async function () {
            const nextPayment = Math.floor(Date.now() / 1000) + 86400; // 1 day
            await collectionAutomator.schedulePayment(tokenId, nextPayment);

            await increaseTime(86401); // Just over 1 day

            expect(await collectionAutomator.isPaymentOverdue(tokenId)).to.be.true;
        });

        it("Should not flag on-time payment as overdue", async function () {
            const nextPayment = Math.floor(Date.now() / 1000) + 86400;
            await collectionAutomator.schedulePayment(tokenId, nextPayment);

            expect(await collectionAutomator.isPaymentOverdue(tokenId)).to.be.false;
        });
    });

    describe("Warning System", function () {
        beforeEach(async function () {
            // Setup security deposit for debtor
            await collectionAutomator.connect(user2).depositSecurity({ value: ethers.parseEther("1000") });
        });

        it("Should issue warning for late payment", async function () {
            await expect(
                collectionAutomator.connect(operator).issueWarning(tokenId, "Payment overdue by 5 days")
            ).to.emit(collectionAutomator, "WarningIssued")
              .withArgs(tokenId, user2.address, 1, "Payment overdue by 5 days");
        });

        it("Should track warning levels", async function () {
            await collectionAutomator.connect(operator).issueWarning(tokenId, "Warning 1");
            expect(await collectionAutomator.getWarningLevel(tokenId)).to.equal(1);

            await collectionAutomator.connect(operator).issueWarning(tokenId, "Warning 2");
            expect(await collectionAutomator.getWarningLevel(tokenId)).to.equal(2);
        });

        it("Should mark as defaulted after max warnings", async function () {
            await collectionAutomator.connect(operator).issueWarning(tokenId, "Warning 1");
            await collectionAutomator.connect(operator).issueWarning(tokenId, "Warning 2");
            await collectionAutomator.connect(operator).issueWarning(tokenId, "Warning 3");

            expect(await collectionAutomator.isDefaulted(tokenId)).to.be.true;
        });

        it("Should enforce warning interval", async function () {
            await collectionAutomator.connect(operator).issueWarning(tokenId, "Warning 1");

            // Try to issue another warning immediately
            await expect(
                collectionAutomator.connect(operator).issueWarning(tokenId, "Warning 2")
            ).to.be.reverted;
        });

        it("Should update reputation on warning", async function () {
            const initialScore = await reputationManager.getReputationScore(user2.address);

            await collectionAutomator.connect(operator).issueWarning(tokenId, "Warning 1");

            const newScore = await reputationManager.getReputationScore(user2.address);
            expect(newScore).to.be.lt(initialScore);
        });
    });

    describe("Slashing", function () {
        beforeEach(async function () {
            await collectionAutomator.connect(user2).depositSecurity({ value: ethers.parseEther("1000") });
        });

        it("Should slash security deposit", async function () {
            const depositBefore = await collectionAutomator.getSecurityDeposit(user2.address);

            await collectionAutomator.connect(operator).slashDeposit(user2.address, tokenId, "Missed payment");

            const depositAfter = await collectionAutomator.getSecurityDeposit(user2.address);
            const slashed = (depositBefore * 2000n) / 10000n; // 20%

            expect(depositAfter).to.equal(depositBefore - slashed);
        });

        it("Should emit slashing event", async function () {
            await expect(
                collectionAutomator.connect(operator).slashDeposit(user2.address, tokenId, "Missed payment")
            ).to.emit(collectionAutomator, "DepositSlashed");
        });

        it("Should track total slashed amount", async function () {
            const initialTotal = await collectionAutomator.totalSlashedAmount();

            await collectionAutomator.connect(operator).slashDeposit(user2.address, tokenId, "Missed payment");

            const newTotal = await collectionAutomator.totalSlashedAmount();
            expect(newTotal).to.be.gt(initialTotal);
        });

        it("Should record slashing history", async function () {
            await collectionAutomator.connect(operator).slashDeposit(user2.address, tokenId, "Missed payment");

            const history = await collectionAutomator.getSlashingHistory(user2.address);
            expect(history.length).to.equal(1);
            expect(history[0].reason).to.equal("Missed payment");
        });

        it("Should revert if insufficient deposit", async function () {
            // Withdraw most of deposit
            await collectionAutomator.connect(user2).withdrawSecurity(ethers.parseEther("900"));

            await expect(
                collectionAutomator.connect(operator).slashDeposit(user2.address, tokenId, "Test")
            ).to.be.reverted;
        });
    });

    describe("Blacklisting", function () {
        it("Should blacklist debtor", async function () {
            await expect(
                collectionAutomator.connect(operator).blacklistDebtor(user2.address, tokenId, "Fraud")
            ).to.emit(collectionAutomator, "DebtorBlacklisted")
              .withArgs(user2.address, tokenId, "Fraud");
        });

        it("Should check blacklist status", async function () {
            await collectionAutomator.connect(operator).blacklistDebtor(user2.address, tokenId, "Fraud");

            expect(await collectionAutomator.isBlacklisted(user2.address)).to.be.true;
        });

        it("Should suspend trading privileges", async function () {
            await collectionAutomator.connect(operator).blacklistDebtor(user2.address, tokenId, "Default");

            expect(await collectionAutomator.isTradingSuspended(user2.address)).to.be.true;
        });

        it("Should set suspension end date", async function () {
            await collectionAutomator.connect(operator).blacklistDebtor(user2.address, tokenId, "Default");

            const endDate = await collectionAutomator.getSuspensionEndDate(user2.address);
            const currentTime = await getCurrentTimestamp();

            expect(endDate).to.be.gt(currentTime);
        });

        it("Should update reputation to minimum", async function () {
            await collectionAutomator.connect(operator).blacklistDebtor(user2.address, tokenId, "Fraud");

            const score = await reputationManager.getReputationScore(user2.address);
            expect(score).to.equal(300); // Minimum score
        });
    });

    describe("Default Management", function () {
        it("Should mark debt as defaulted", async function () {
            await collectionAutomator.connect(operator).markAsDefaulted(tokenId);

            expect(await collectionAutomator.isDefaulted(tokenId)).to.be.true;
        });

        it("Should track total defaults", async function () {
            const initialDefaults = await collectionAutomator.totalDefaults();

            await collectionAutomator.connect(operator).markAsDefaulted(tokenId);

            expect(await collectionAutomator.totalDefaults()).to.equal(initialDefaults + 1n);
        });

        it("Should create default record", async function () {
            await collectionAutomator.connect(operator).markAsDefaulted(tokenId);

            const record = await collectionAutomator.getDefaultRecord(tokenId);
            expect(record.tokenId).to.equal(tokenId);
            expect(record.debtor).to.equal(user2.address);
        });

        it("Should prevent double default marking", async function () {
            await collectionAutomator.connect(operator).markAsDefaulted(tokenId);

            await expect(
                collectionAutomator.connect(operator).markAsDefaulted(tokenId)
            ).to.be.reverted;
        });
    });

    describe("Liquidation", function () {
        it("Should initiate liquidation", async function () {
            await collectionAutomator.connect(operator).markAsDefaulted(tokenId);

            await expect(
                collectionAutomator.connect(operator).initiateLiquidation(tokenId)
            ).to.emit(collectionAutomator, "LiquidationStarted")
              .withArgs(tokenId);
        });

        it("Should track liquidation status", async function () {
            await collectionAutomator.connect(operator).markAsDefaulted(tokenId);
            await collectionAutomator.connect(operator).initiateLiquidation(tokenId);

            expect(await collectionAutomator.isLiquidationInProgress(tokenId)).to.be.true;
        });

        it("Should prevent liquidation of non-defaulted debt", async function () {
            await expect(
                collectionAutomator.connect(operator).initiateLiquidation(tokenId)
            ).to.be.reverted;
        });

        it("Should track total liquidations", async function () {
            await collectionAutomator.connect(operator).markAsDefaulted(tokenId);
            const initialTotal = await collectionAutomator.totalLiquidations();

            await collectionAutomator.connect(operator).initiateLiquidation(tokenId);

            expect(await collectionAutomator.totalLiquidations()).to.equal(initialTotal + 1n);
        });
    });

    describe("Configuration", function () {
        it("Should update security deposit amount", async function () {
            await collectionAutomator.setDefaultSecurityDeposit(ethers.parseEther("2000"));
            expect(await collectionAutomator.defaultSecurityDepositAmount()).to.equal(ethers.parseEther("2000"));
        });

        it("Should update slashing percentage", async function () {
            await collectionAutomator.setSlashingPercentage(3000); // 30%
            expect(await collectionAutomator.slashingPercentage()).to.equal(3000);
        });

        it("Should update max warnings", async function () {
            await collectionAutomator.setMaxWarnings(5);
            expect(await collectionAutomator.maxWarningsBeforeDefault()).to.equal(5);
        });

        it("Should update trading suspension duration", async function () {
            await collectionAutomator.setTradingSuspensionDuration(604800); // 7 days
            expect(await collectionAutomator.tradingSuspensionDuration()).to.equal(604800);
        });

        it("Should not allow non-admin to change config", async function () {
            await expect(
                collectionAutomator.connect(user1).setSlashingPercentage(3000)
            ).to.be.reverted;
        });

        it("Should not allow slashing percentage over 100%", async function () {
            await expect(
                collectionAutomator.setSlashingPercentage(10001)
            ).to.be.reverted;
        });
    });

    describe("Statistics", function () {
        it("Should track defaults correctly", async function () {
            const initial = await collectionAutomator.totalDefaults();

            await collectionAutomator.connect(operator).markAsDefaulted(tokenId);

            expect(await collectionAutomator.totalDefaults()).to.equal(initial + 1n);
        });

        it("Should track slashed amounts", async function () {
            await collectionAutomator.connect(user2).depositSecurity({ value: ethers.parseEther("1000") });

            await collectionAutomator.connect(operator).slashDeposit(user2.address, tokenId, "Test");

            expect(await collectionAutomator.totalSlashedAmount()).to.be.gt(0);
        });

        it("Should get all defaulted tokens", async function () {
            await collectionAutomator.connect(operator).markAsDefaulted(tokenId);

            const defaulted = await collectionAutomator.getAllDefaultedTokens();
            expect(defaulted).to.include(tokenId);
        });
    });

    describe("Access Control", function () {
        it("Should only allow operator to issue warnings", async function () {
            await expect(
                collectionAutomator.connect(user1).issueWarning(tokenId, "Test")
            ).to.be.reverted;
        });

        it("Should only allow operator to slash deposits", async function () {
            await collectionAutomator.connect(user2).depositSecurity({ value: ethers.parseEther("1000") });

            await expect(
                collectionAutomator.connect(user1).slashDeposit(user2.address, tokenId, "Test")
            ).to.be.reverted;
        });

        it("Should only allow operator to blacklist", async function () {
            await expect(
                collectionAutomator.connect(user1).blacklistDebtor(user2.address, tokenId, "Test")
            ).to.be.reverted;
        });
    });

    describe("Pausable", function () {
        it("Should pause contract", async function () {
            await collectionAutomator.pause();
            expect(await collectionAutomator.paused()).to.be.true;
        });

        it("Should prevent operations when paused", async function () {
            await collectionAutomator.pause();

            await expect(
                collectionAutomator.connect(user2).depositSecurity({ value: ethers.parseEther("1000") })
            ).to.be.reverted;
        });

        it("Should unpause contract", async function () {
            await collectionAutomator.pause();
            await collectionAutomator.unpause();
            expect(await collectionAutomator.paused()).to.be.false;
        });
    });
});
