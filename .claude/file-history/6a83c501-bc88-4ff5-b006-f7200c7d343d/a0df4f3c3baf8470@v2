// SPDX-License-Identifier: MIT
pragma solidity 0.8.25;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "../interfaces/IBTTBInterfaces.sol";

/**
 * @title EscrowSettlement
 * @dev Manages escrow for custody operations and handles dispute resolution
 * @notice This contract holds funds during the custody verification period
 * and provides dispute resolution mechanisms for failed operations
 * @custom:security-contact security@bancafi.io
 */
contract EscrowSettlement is ReentrancyGuard, AccessControl, Pausable {

    bytes32 public constant ARBITER_ROLE = keccak256("ARBITER_ROLE");
    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");

    struct EscrowDeposit {
        uint256 escrowId;
        address depositor;
        address beneficiary;
        address token;              // Bond token or crypto token
        uint256 amount;
        uint256 createdAt;
        uint256 releaseTime;        // Timelock for automatic release
        EscrowStatus status;
        EscrowType escrowType;
        bytes32 referenceId;        // Links to custody request or other operation
        string metadata;            // IPFS hash or additional info
        DisputeInfo dispute;
    }

    struct DisputeInfo {
        bool isDisputed;
        address disputeInitiator;
        uint256 disputeTime;
        string disputeReason;
        DisputeResolution resolution;
        address arbiter;
        uint256 resolvedAt;
    }

    enum EscrowStatus {
        ACTIVE,              // Funds in escrow
        RELEASED,            // Released to beneficiary
        REFUNDED,            // Refunded to depositor
        DISPUTED,            // Under dispute
        RESOLVED_RELEASE,    // Dispute resolved, release to beneficiary
        RESOLVED_REFUND,     // Dispute resolved, refund to depositor
        EXPIRED              // Expired and ready for claim
    }

    enum EscrowType {
        CUSTODY_DEPOSIT,     // Escrow for deposit requests
        CUSTODY_WITHDRAWAL,  // Escrow for withdrawal requests
        CONVERSION,          // Escrow for conversions
        COUPON_PAYMENT,      // Escrow for coupon distributions
        GENERAL              // General purpose escrow
    }

    enum DisputeResolution {
        PENDING,
        RELEASE_TO_BENEFICIARY,
        REFUND_TO_DEPOSITOR,
        SPLIT_PAYMENT        // Partial refund/release
    }

    // State variables
    uint256 public nextEscrowId;
    mapping(uint256 => EscrowDeposit) public escrows;
    mapping(address => uint256[]) public userEscrows;
    mapping(bytes32 => uint256) public referenceToEscrow; // Map external reference to escrow
    mapping(bytes32 => bool) public referenceExists; // ✅ FIX: Track if reference exists

    // Configuration
    uint256 public defaultEscrowPeriod = 7 days;
    uint256 public disputePeriod = 14 days;
    uint256 public minEscrowAmount = 1e6; // Minimum amount (adjust per token)
    uint256 public maxBatchSize = 50; // ✅ FIX: Limit batch operations

    // Statistics
    uint256 public totalEscrowed;
    uint256 public totalReleased;
    uint256 public totalRefunded;
    uint256 public totalDisputes;

    // Events
    event EscrowCreated(
        uint256 indexed escrowId,
        address indexed depositor,
        address indexed beneficiary,
        address token,
        uint256 amount,
        EscrowType escrowType
    );
    event EscrowReleased(uint256 indexed escrowId, address indexed beneficiary, uint256 amount);
    event EscrowRefunded(uint256 indexed escrowId, address indexed depositor, uint256 amount);
    event DisputeRaised(uint256 indexed escrowId, address indexed initiator, string reason);
    event DisputeResolved(
        uint256 indexed escrowId,
        DisputeResolution resolution,
        address indexed arbiter
    );
    event EscrowExtended(uint256 indexed escrowId, uint256 newReleaseTime);
    event EscrowCancelled(uint256 indexed escrowId);

    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ARBITER_ROLE, msg.sender);
        _grantRole(OPERATOR_ROLE, msg.sender);
    }

    /**
     * @dev Create escrow deposit
     * @param beneficiary Address that will receive funds upon release
     * @param token Token address (bond token or crypto)
     * @param amount Amount to escrow
     * @param escrowType Type of escrow
     * @param referenceId External reference (custody request ID, etc.)
     * @param customReleaseTime Custom release time in seconds (0 for default)
     * @return escrowId The ID of the created escrow
     */
    function createEscrow(
        address beneficiary,
        address token,
        uint256 amount,
        EscrowType escrowType,
        bytes32 referenceId,
        uint256 customReleaseTime
    ) external nonReentrant whenNotPaused returns (uint256) {
        require(beneficiary != address(0), "Invalid beneficiary");
        require(token != address(0), "Invalid token"); // ✅ FIX: Added validation
        require(amount >= minEscrowAmount, "Amount too low");
        require(
            !referenceExists[referenceId] || referenceId == bytes32(0),
            "Reference already used"
        ); // ✅ FIX: Check existence mapping

        // Transfer tokens to escrow
        require(
            IERC20(token).transferFrom(msg.sender, address(this), amount),
            "Transfer failed"
        );

        uint256 escrowId = nextEscrowId++;
        uint256 releaseTime = customReleaseTime > 0
            ? block.timestamp + customReleaseTime
            : block.timestamp + defaultEscrowPeriod;

        escrows[escrowId] = EscrowDeposit({
            escrowId: escrowId,
            depositor: msg.sender,
            beneficiary: beneficiary,
            token: token,
            amount: amount,
            createdAt: block.timestamp,
            releaseTime: releaseTime,
            status: EscrowStatus.ACTIVE,
            escrowType: escrowType,
            referenceId: referenceId,
            metadata: "",
            dispute: DisputeInfo({
                isDisputed: false,
                disputeInitiator: address(0),
                disputeTime: 0,
                disputeReason: "",
                resolution: DisputeResolution.PENDING,
                arbiter: address(0),
                resolvedAt: 0
            })
        });

        userEscrows[msg.sender].push(escrowId);
        userEscrows[beneficiary].push(escrowId);

        if (referenceId != bytes32(0)) {
            referenceToEscrow[referenceId] = escrowId;
            referenceExists[referenceId] = true; // ✅ FIX: Mark reference as used
        }

        totalEscrowed += amount;

        emit EscrowCreated(
            escrowId,
            msg.sender,
            beneficiary,
            token,
            amount,
            escrowType
        );

        return escrowId;
    }

    /**
     * @dev Release escrow to beneficiary (can be called by operator or after timelock)
     * @param escrowId The ID of the escrow to release
     */
    function releaseEscrow(uint256 escrowId) external nonReentrant {
        EscrowDeposit storage escrow = escrows[escrowId];

        require(escrow.status == EscrowStatus.ACTIVE, "Invalid status");
        require(!escrow.dispute.isDisputed, "Escrow is disputed");
        require(
            hasRole(OPERATOR_ROLE, msg.sender) ||
            block.timestamp >= escrow.releaseTime ||
            msg.sender == escrow.depositor,
            "Not authorized or too early"
        );

        escrow.status = EscrowStatus.RELEASED;

        require(
            IERC20(escrow.token).transfer(escrow.beneficiary, escrow.amount),
            "Transfer failed"
        );

        totalReleased += escrow.amount;

        emit EscrowReleased(escrowId, escrow.beneficiary, escrow.amount);
    }

    /**
     * @dev Refund escrow to depositor (operator only, or in case of failed custody)
     * @param escrowId The ID of the escrow to refund
     * @param reason Reason for refund
     */
    function refundEscrow(uint256 escrowId, string memory reason)
        external
        onlyRole(OPERATOR_ROLE)
        nonReentrant
    {
        EscrowDeposit storage escrow = escrows[escrowId];

        require(
            escrow.status == EscrowStatus.ACTIVE ||
            escrow.status == EscrowStatus.DISPUTED,
            "Invalid status"
        );

        escrow.status = EscrowStatus.REFUNDED;
        escrow.metadata = reason;

        require(
            IERC20(escrow.token).transfer(escrow.depositor, escrow.amount),
            "Transfer failed"
        );

        totalRefunded += escrow.amount;

        emit EscrowRefunded(escrowId, escrow.depositor, escrow.amount);
    }

    /**
     * @dev Raise dispute on escrow
     * @param escrowId The ID of the escrow to dispute
     * @param reason Reason for dispute
     */
    function raiseDispute(uint256 escrowId, string memory reason) external {
        EscrowDeposit storage escrow = escrows[escrowId];

        require(escrow.status == EscrowStatus.ACTIVE, "Invalid status");
        require(
            msg.sender == escrow.depositor || msg.sender == escrow.beneficiary,
            "Not authorized"
        );
        require(!escrow.dispute.isDisputed, "Already disputed");
        require(
            block.timestamp <= escrow.releaseTime + disputePeriod,
            "Dispute period expired"
        );

        escrow.status = EscrowStatus.DISPUTED;
        escrow.dispute.isDisputed = true;
        escrow.dispute.disputeInitiator = msg.sender;
        escrow.dispute.disputeTime = block.timestamp;
        escrow.dispute.disputeReason = reason;

        totalDisputes++;

        emit DisputeRaised(escrowId, msg.sender, reason);
    }

    /**
     * @dev Resolve dispute (arbiter only)
     * @param escrowId The ID of the escrow with dispute
     * @param resolution Resolution type
     * @param refundAmount Amount to refund (only used for SPLIT_PAYMENT)
     */
    function resolveDispute(
        uint256 escrowId,
        DisputeResolution resolution,
        uint256 refundAmount
    ) external onlyRole(ARBITER_ROLE) nonReentrant {
        EscrowDeposit storage escrow = escrows[escrowId];

        require(escrow.status == EscrowStatus.DISPUTED, "Not disputed");
        require(escrow.dispute.isDisputed, "No active dispute");

        escrow.dispute.resolution = resolution;
        escrow.dispute.arbiter = msg.sender;
        escrow.dispute.resolvedAt = block.timestamp;

        if (resolution == DisputeResolution.RELEASE_TO_BENEFICIARY) {
            escrow.status = EscrowStatus.RESOLVED_RELEASE;
            require(
                IERC20(escrow.token).transfer(escrow.beneficiary, escrow.amount),
                "Transfer failed"
            );
            totalReleased += escrow.amount;
            emit EscrowReleased(escrowId, escrow.beneficiary, escrow.amount);

        } else if (resolution == DisputeResolution.REFUND_TO_DEPOSITOR) {
            escrow.status = EscrowStatus.RESOLVED_REFUND;
            require(
                IERC20(escrow.token).transfer(escrow.depositor, escrow.amount),
                "Transfer failed"
            );
            totalRefunded += escrow.amount;
            emit EscrowRefunded(escrowId, escrow.depositor, escrow.amount);

        } else if (resolution == DisputeResolution.SPLIT_PAYMENT) {
            require(refundAmount <= escrow.amount, "Invalid split amount");
            escrow.status = EscrowStatus.RESOLVED_RELEASE;

            uint256 releaseAmount = escrow.amount - refundAmount;

            if (refundAmount > 0) {
                require(
                    IERC20(escrow.token).transfer(escrow.depositor, refundAmount),
                    "Refund failed"
                );
                totalRefunded += refundAmount;
            }

            if (releaseAmount > 0) {
                require(
                    IERC20(escrow.token).transfer(escrow.beneficiary, releaseAmount),
                    "Release failed"
                );
                totalReleased += releaseAmount;
            }
        }

        emit DisputeResolved(escrowId, resolution, msg.sender);
    }

    /**
     * @dev Extend escrow release time (operator only)
     * @param escrowId The ID of the escrow to extend
     * @param additionalTime Additional time in seconds
     */
    function extendEscrow(uint256 escrowId, uint256 additionalTime)
        external
        onlyRole(OPERATOR_ROLE)
    {
        EscrowDeposit storage escrow = escrows[escrowId];

        require(escrow.status == EscrowStatus.ACTIVE, "Invalid status");
        require(additionalTime > 0 && additionalTime <= 30 days, "Invalid extension");

        escrow.releaseTime += additionalTime;

        emit EscrowExtended(escrowId, escrow.releaseTime);
    }

    /**
     * @dev Cancel and refund escrow before release time (depositor only, within grace period)
     * @param escrowId The ID of the escrow to cancel
     */
    function cancelEscrow(uint256 escrowId) external nonReentrant {
        EscrowDeposit storage escrow = escrows[escrowId];

        require(escrow.status == EscrowStatus.ACTIVE, "Invalid status");
        require(msg.sender == escrow.depositor, "Not depositor");
        require(
            block.timestamp < escrow.createdAt + 1 hours,
            "Cancellation period expired"
        );

        escrow.status = EscrowStatus.REFUNDED;

        require(
            IERC20(escrow.token).transfer(escrow.depositor, escrow.amount),
            "Transfer failed"
        );

        totalRefunded += escrow.amount;

        emit EscrowCancelled(escrowId);
        emit EscrowRefunded(escrowId, escrow.depositor, escrow.amount);
    }

    /**
     * @dev Batch release multiple escrows (operator only)
     * @param escrowIds Array of escrow IDs to release
     */
    function batchReleaseEscrow(uint256[] calldata escrowIds)
        external
        onlyRole(OPERATOR_ROLE)
        nonReentrant
    {
        require(escrowIds.length <= maxBatchSize, "Batch too large"); // ✅ FIX: Added limit

        uint256 length = escrowIds.length; // ✅ FIX: Cache array length
        for (uint256 i = 0; i < length; ) {
            uint256 escrowId = escrowIds[i];
            EscrowDeposit storage escrow = escrows[escrowId];

            if (escrow.status == EscrowStatus.ACTIVE && !escrow.dispute.isDisputed) {
                escrow.status = EscrowStatus.RELEASED;

                require(
                    IERC20(escrow.token).transfer(escrow.beneficiary, escrow.amount),
                    "Transfer failed"
                );

                totalReleased += escrow.amount;

                emit EscrowReleased(escrowId, escrow.beneficiary, escrow.amount);
            }

            unchecked { ++i; } // ✅ FIX: Gas optimization
        }
    }

    /**
     * @dev Get escrow by reference ID
     * @param referenceId The reference ID to look up
     * @return The escrow deposit details
     */
    function getEscrowByReference(bytes32 referenceId)
        external
        view
        returns (EscrowDeposit memory)
    {
        require(referenceExists[referenceId], "Reference not found"); // ✅ FIX: Check existence
        uint256 escrowId = referenceToEscrow[referenceId];
        return escrows[escrowId];
    }

    /**
     * @dev Get user's escrow IDs
     * @param user The user address
     * @return Array of escrow IDs
     */
    function getUserEscrows(address user)
        external
        view
        returns (uint256[] memory)
    {
        return userEscrows[user];
    }

    /**
     * @dev Get escrow statistics
     * @return _totalEscrowed Total amount escrowed
     * @return _totalReleased Total amount released
     * @return _totalRefunded Total amount refunded
     * @return _totalDisputes Total number of disputes
     * @return _activeEscrows Total number of escrows created
     */
    function getEscrowStats()
        external
        view
        returns (
            uint256 _totalEscrowed,
            uint256 _totalReleased,
            uint256 _totalRefunded,
            uint256 _totalDisputes,
            uint256 _activeEscrows
        )
    {
        return (
            totalEscrowed,
            totalReleased,
            totalRefunded,
            totalDisputes,
            nextEscrowId
        );
    }

    /**
     * @dev Check if escrow is ready for release
     * @param escrowId The ID of the escrow to check
     * @return True if escrow can be released
     */
    function isEscrowReleasable(uint256 escrowId)
        external
        view
        returns (bool)
    {
        EscrowDeposit memory escrow = escrows[escrowId]; // ✅ FIX: Use memory in view
        return escrow.status == EscrowStatus.ACTIVE &&
               !escrow.dispute.isDisputed &&
               block.timestamp >= escrow.releaseTime;
    }

    /**
     * @dev Update configuration (admin only)
     * @param _defaultEscrowPeriod New default escrow period
     * @param _disputePeriod New dispute period
     * @param _minEscrowAmount New minimum escrow amount
     */
    function updateConfig(
        uint256 _defaultEscrowPeriod,
        uint256 _disputePeriod,
        uint256 _minEscrowAmount
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_defaultEscrowPeriod <= 30 days, "Period too long");
        require(_disputePeriod <= 90 days, "Dispute period too long");

        defaultEscrowPeriod = _defaultEscrowPeriod;
        disputePeriod = _disputePeriod;
        minEscrowAmount = _minEscrowAmount;
    }

    /**
     * @dev Update max batch size (admin only)
     * @param _maxBatchSize New maximum batch size
     */
    function updateMaxBatchSize(uint256 _maxBatchSize)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        require(_maxBatchSize > 0 && _maxBatchSize <= 100, "Invalid batch size");
        maxBatchSize = _maxBatchSize;
    }

    /**
     * @dev Emergency pause
     */
    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {
        _pause();
    }

    /**
     * @dev Unpause contract
     */
    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {
        _unpause();
    }

    /**
     * @dev Emergency withdraw (admin only, for stuck funds)
     * @param token Token address to withdraw
     * @param recipient Recipient address
     * @param amount Amount to withdraw
     */
    function emergencyWithdraw(
        address token,
        address recipient,
        uint256 amount
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(paused(), "Not in emergency mode");
        require(recipient != address(0), "Invalid recipient"); // ✅ FIX: Added validation
        require(
            IERC20(token).transfer(recipient, amount),
            "Transfer failed"
        );
    }
}
