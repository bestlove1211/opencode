// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

interface IBancafiAssetToken {
    enum AssetStatus { Pending, Verified, Active, Locked, Defaulted }
    function updateAssetStatus(uint256 tokenId, AssetStatus newStatus) external;
    function ownerOf(uint256 tokenId) external view returns (address);
    function transferFrom(address from, address to, uint256 tokenId) external;
}

/**
 * @title BancafiBailout
 * @notice DAO-governed bailout mechanism for tokenized entities
 */
contract BancafiBailout is
    Initializable,
    AccessControlUpgradeable,
    PausableUpgradeable,
    ReentrancyGuardUpgradeable,
    UUPSUpgradeable,
    IERC721Receiver
{
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");
    bytes32 public constant TREASURY_MANAGER_ROLE = keccak256("TREASURY_MANAGER_ROLE");
    bytes32 public constant BAILOUT_APPROVER_ROLE = keccak256("BAILOUT_APPROVER_ROLE");

    enum BailoutStatus {
        Pending,
        Approved,
        Disbursed,
        Repaying,
        Completed,
        Defaulted,
        Rejected
    }

    struct BailoutRequest {
        uint256 requestId;
        address requester;
        uint256 amount;
        uint256 requestedAt;
        uint256 approvedAt;
        uint256 disbursedAt;
        uint256 dueDate;
        uint256 interestRate;
        BailoutStatus status;
        string reason;
        string solvencyProof;
        uint256 collateralTokenId;
        uint256 repaidAmount;
        address approver;
    }

    struct RepaymentSchedule {
        uint256 bailoutId;
        uint256 totalAmount;
        uint256 amountPaid;
        uint256 installmentAmount;
        uint256 installmentCount;
        uint256 nextPaymentDue;
        uint256 paymentInterval;
        bool isActive;
    }

    uint256 private _bailoutIds;
    mapping(uint256 => BailoutRequest) public bailoutRequests;
    mapping(uint256 => RepaymentSchedule) public repaymentSchedules;
    mapping(address => uint256[]) public userBailouts;
    mapping(address => uint256) public userActiveBailouts;

    IBancafiAssetToken public assetToken;
    address public TREASURY;
    uint256 public constant GRACE_PERIOD = 7 days;

    uint256 public treasuryBalance;
    uint256 public totalDisbursed;
    uint256 public totalRepaid;
    uint256 public maxBailoutAmount;
    uint256 public minCollateralRatio;

    event BailoutRequested(uint256 indexed requestId, address indexed requester, uint256 amount, uint256 timestamp);
    event BailoutApproved(uint256 indexed requestId, address indexed approver, uint256 amount, uint256 timestamp);
    event BailoutDisbursed(uint256 indexed requestId, address indexed recipient, uint256 amount, uint256 timestamp);
    event BailoutRepayment(uint256 indexed requestId, address indexed payer, uint256 amount, uint256 remainingBalance, uint256 timestamp);
    event BailoutCompleted(uint256 indexed requestId, uint256 totalRepaid, uint256 timestamp);
    event BailoutDefaulted(uint256 indexed requestId, uint256 outstandingAmount, uint256 timestamp);
    event BailoutRejected(uint256 indexed requestId, address indexed rejector, string reason, uint256 timestamp);
    event TreasuryDeposit(address indexed depositor, uint256 amount, uint256 newBalance, uint256 timestamp);
    event TreasuryWithdrawal(address indexed recipient, uint256 amount, uint256 newBalance, uint256 timestamp);
    event MaxBailoutAmountUpdated(uint256 oldAmount, uint256 newAmount, uint256 timestamp);

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(
        uint256 maxBailoutAmount_,
        uint256 minCollateralRatio_,
        address assetTokenAddress_,
        address treasury_
    ) public initializer {
        __AccessControl_init();
        __Pausable_init();
        __ReentrancyGuard_init();
        __UUPSUpgradeable_init();

        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(PAUSER_ROLE, msg.sender);
        _grantRole(UPGRADER_ROLE, msg.sender);
        _grantRole(TREASURY_MANAGER_ROLE, msg.sender);
        _grantRole(BAILOUT_APPROVER_ROLE, msg.sender);

        maxBailoutAmount = maxBailoutAmount_;
        minCollateralRatio = minCollateralRatio_;
        assetToken = IBancafiAssetToken(assetTokenAddress_);
        TREASURY = treasury_;
    }

    function requestBailout(
        uint256 amount_,
        string memory reason_,
        string memory solvencyProof_,
        uint256 collateralTokenId_,
        uint256 repaymentMonths_
    ) external whenNotPaused nonReentrant returns (uint256) {
        require(amount_ > 0, "Amount must be > 0");
        require(amount_ <= maxBailoutAmount, "Exceeds max bailout");
        require(userActiveBailouts[msg.sender] == 0, "Active bailout exists");

        _bailoutIds++;
        uint256 requestId = _bailoutIds;

        bailoutRequests[requestId] = BailoutRequest({
            requestId: requestId,
            requester: msg.sender,
            amount: amount_,
            requestedAt: block.timestamp,
            approvedAt: 0,
            disbursedAt: 0,
            dueDate: block.timestamp + (repaymentMonths_ * 30 days),
            interestRate: 500,
            status: BailoutStatus.Pending,
            reason: reason_,
            solvencyProof: solvencyProof_,
            collateralTokenId: collateralTokenId_,
            repaidAmount: 0,
            approver: address(0)
        });

        userBailouts[msg.sender].push(requestId);
        userActiveBailouts[msg.sender] = requestId;

        // Transfer collateral NFT to bailout contract
        assetToken.transferFrom(msg.sender, address(this), collateralTokenId_);

        // Lock collateral asset
        assetToken.updateAssetStatus(collateralTokenId_, IBancafiAssetToken.AssetStatus.Locked);

        emit BailoutRequested(requestId, msg.sender, amount_, block.timestamp);
        return requestId;
    }

    function approveBailout(
        uint256 requestId_,
        uint256 interestRate_
    ) external whenNotPaused onlyRole(BAILOUT_APPROVER_ROLE) {
        BailoutRequest storage request = bailoutRequests[requestId_];
        require(request.status == BailoutStatus.Pending, "Not pending");
        require(treasuryBalance >= request.amount, "Insufficient treasury");

        request.status = BailoutStatus.Approved;
        request.approvedAt = block.timestamp;
        request.approver = msg.sender;
        request.interestRate = interestRate_;

        emit BailoutApproved(requestId_, msg.sender, request.amount, block.timestamp);
    }

    function disburseBailout(
        uint256 requestId_,
        uint256 installmentCount_
    ) external whenNotPaused nonReentrant onlyRole(TREASURY_MANAGER_ROLE) {
        BailoutRequest storage request = bailoutRequests[requestId_];
        require(request.status == BailoutStatus.Approved, "Not approved");
        require(treasuryBalance >= request.amount, "Insufficient treasury");
        require(installmentCount_ > 0, "Invalid installment count");

        uint256 totalWithInterest = request.amount + (request.amount * request.interestRate / 10000);
        uint256 installmentAmount = totalWithInterest / installmentCount_;
        uint256 paymentInterval = (request.dueDate - block.timestamp) / installmentCount_;

        treasuryBalance -= request.amount;
        totalDisbursed += request.amount;

        request.status = BailoutStatus.Disbursed;
        request.disbursedAt = block.timestamp;

        repaymentSchedules[requestId_] = RepaymentSchedule({
            bailoutId: requestId_,
            totalAmount: totalWithInterest,
            amountPaid: 0,
            installmentAmount: installmentAmount,
            installmentCount: installmentCount_,
            nextPaymentDue: block.timestamp + paymentInterval,
            paymentInterval: paymentInterval,
            isActive: true
        });

        (bool success, ) = request.requester.call{value: request.amount}("");
        require(success, "Transfer failed");

        emit BailoutDisbursed(requestId_, request.requester, request.amount, block.timestamp);
    }

    function repayBailout(uint256 requestId_) external payable whenNotPaused nonReentrant {
        BailoutRequest storage request = bailoutRequests[requestId_];
        RepaymentSchedule storage schedule = repaymentSchedules[requestId_];

        require(request.requester == msg.sender, "Not requester");
        require(request.status == BailoutStatus.Disbursed || request.status == BailoutStatus.Repaying, "Cannot repay");
        require(schedule.isActive, "Schedule not active");
        require(msg.value > 0, "Payment required");

        uint256 remainingBalance = schedule.totalAmount - schedule.amountPaid;
        require(msg.value <= remainingBalance, "Overpayment");

        schedule.amountPaid += msg.value;
        request.repaidAmount += msg.value;
        treasuryBalance += msg.value;
        totalRepaid += msg.value;

        if (request.status == BailoutStatus.Disbursed) {
            request.status = BailoutStatus.Repaying;
        }

        emit BailoutRepayment(requestId_, msg.sender, msg.value, remainingBalance - msg.value, block.timestamp);

        if (schedule.amountPaid >= schedule.totalAmount) {
            request.status = BailoutStatus.Completed;
            schedule.isActive = false;
            userActiveBailouts[msg.sender] = 0;

            // Return collateral NFT to borrower
            assetToken.transferFrom(address(this), request.requester, request.collateralTokenId);

            // Unlock collateral asset (set back to Verified status)
            assetToken.updateAssetStatus(request.collateralTokenId, IBancafiAssetToken.AssetStatus.Verified);

            emit BailoutCompleted(requestId_, schedule.amountPaid, block.timestamp);
        } else {
            schedule.nextPaymentDue = block.timestamp + schedule.paymentInterval;
        }
    }

    function rejectBailout(
        uint256 requestId_,
        string memory rejectionReason_
    ) external onlyRole(BAILOUT_APPROVER_ROLE) {
        BailoutRequest storage request = bailoutRequests[requestId_];
        require(request.status == BailoutStatus.Pending, "Not pending");

        request.status = BailoutStatus.Rejected;
        userActiveBailouts[request.requester] = 0;

        emit BailoutRejected(requestId_, msg.sender, rejectionReason_, block.timestamp);
    }

    function checkDefault(uint256 requestId_) external whenNotPaused {
        BailoutRequest storage request = bailoutRequests[requestId_];
        RepaymentSchedule storage schedule = repaymentSchedules[requestId_];

        require(
            request.status == BailoutStatus.Disbursed || request.status == BailoutStatus.Repaying,
            "Not active bailout"
        );
        require(schedule.isActive, "Schedule not active");

        // Check if past due date + grace period
        require(block.timestamp > request.dueDate + GRACE_PERIOD, "Not yet defaulted");

        // Check if not fully repaid
        require(schedule.amountPaid < schedule.totalAmount, "Already repaid");

        // Mark as defaulted
        request.status = BailoutStatus.Defaulted;
        schedule.isActive = false;
        userActiveBailouts[request.requester] = 0;

        // Transfer collateral NFT to treasury
        assetToken.transferFrom(address(this), TREASURY, request.collateralTokenId);

        // Mark asset as defaulted
        assetToken.updateAssetStatus(request.collateralTokenId, IBancafiAssetToken.AssetStatus.Defaulted);

        uint256 outstandingAmount = schedule.totalAmount - schedule.amountPaid;
        emit BailoutDefaulted(requestId_, outstandingAmount, block.timestamp);
    }

    function depositToTreasury() external payable whenNotPaused nonReentrant {
        require(msg.value > 0, "Amount must be > 0");
        treasuryBalance += msg.value;
        emit TreasuryDeposit(msg.sender, msg.value, treasuryBalance, block.timestamp);
    }

    function pause() external onlyRole(PAUSER_ROLE) {
        _pause();
    }

    function unpause() external onlyRole(PAUSER_ROLE) {
        _unpause();
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

    function _authorizeUpgrade(address newImplementation) internal override onlyRole(UPGRADER_ROLE) {}

    receive() external payable {
        treasuryBalance += msg.value;
        emit TreasuryDeposit(msg.sender, msg.value, treasuryBalance, block.timestamp);
    }
}
