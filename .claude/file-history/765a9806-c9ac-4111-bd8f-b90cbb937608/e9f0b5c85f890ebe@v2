const { expect } = require("chai");
const { ethers, upgrades } = require("hardhat");

/**
 * Security Test Suite: C-1 Asset Validation
 *
 * Tests for the asset validation security fix that ensures proper balance verification
 * when locking collateral, preventing phantom collateral attacks.
 *
 * Vulnerability: Missing balance verification allowed attackers to lock collateral
 * without actually transferring tokens.
 *
 * Fix: Added balance verification before and after transfer in lockCollateralWithTransfer()
 */
describe("Security Tests: C-1 Asset Validation", function () {
  let collateralManager;
  let mockERC20, feeOnTransferToken;
  let owner, user1, attacker, authorizedCaller;

  beforeEach(async function () {
    [owner, user1, attacker, authorizedCaller] = await ethers.getSigners();

    // Deploy CollateralManager
    const CollateralManager = await ethers.getContractFactory("CollateralManager");
    collateralManager = await upgrades.deployProxy(
      CollateralManager,
      [],
      { initializer: "initialize", kind: "uups" }
    );
    await collateralManager.waitForDeployment();

    // Deploy standard mock ERC20
    const MockERC20 = await ethers.getContractFactory("MockERC20");
    mockERC20 = await MockERC20.deploy("Mock Token", "MOCK", 18);
    await mockERC20.waitForDeployment();

    // Deploy fee-on-transfer token
    const FeeOnTransferToken = await ethers.getContractFactory("MockERC20");
    feeOnTransferToken = await FeeOnTransferToken.deploy("Fee Token", "FEE", 18);
    await feeOnTransferToken.waitForDeployment();

    // Configure assets
    await collateralManager.configureAsset(
      await mockERC20.getAddress(),
      true,  // isSupported
      8000,  // liquidationThreshold
      15000, // minCollateralRatio
      ethers.ZeroAddress // priceOracle
    );

    await collateralManager.configureAsset(
      await feeOnTransferToken.getAddress(),
      true,
      8000,
      15000,
      ethers.ZeroAddress
    );

    // Set asset prices
    await collateralManager.updateAssetPrice(
      await mockERC20.getAddress(),
      ethers.parseEther("100") // $100 per token
    );

    await collateralManager.updateAssetPrice(
      await feeOnTransferToken.getAddress(),
      ethers.parseEther("100")
    );

    // Authorize caller
    await collateralManager.setAuthorizedCaller(authorizedCaller.address, true);

    // Mint tokens
    await mockERC20.mint(owner.address, ethers.parseEther("1000"));
    await mockERC20.mint(user1.address, ethers.parseEther("1000"));
    await mockERC20.mint(authorizedCaller.address, ethers.parseEther("1000"));
    await feeOnTransferToken.mint(owner.address, ethers.parseEther("1000"));
    await feeOnTransferToken.mint(user1.address, ethers.parseEther("1000"));
    await feeOnTransferToken.mint(authorizedCaller.address, ethers.parseEther("1000"));
  });

  describe("C-1.1: Balance Verification on Lock", function () {
    it("Should verify actual token receipt in lockCollateralWithTransfer", async function () {
      const amount = ethers.parseEther("100");

      // Approve tokens
      await mockERC20.connect(authorizedCaller).approve(
        await collateralManager.getAddress(),
        amount
      );

      const contractBalanceBefore = await mockERC20.balanceOf(
        await collateralManager.getAddress()
      );

      // Lock collateral with transfer
      await collateralManager.connect(authorizedCaller).lockCollateralWithTransfer(
        user1.address,
        await mockERC20.getAddress(),
        amount
      );

      const contractBalanceAfter = await mockERC20.balanceOf(
        await collateralManager.getAddress()
      );

      // Verify actual transfer occurred
      expect(contractBalanceAfter - contractBalanceBefore).to.equal(amount);
    });

    it("Should handle fee-on-transfer tokens correctly", async function () {
      const amount = ethers.parseEther("100");

      // Approve tokens
      await feeOnTransferToken.connect(authorizedCaller).approve(
        await collateralManager.getAddress(),
        amount
      );

      const contractBalanceBefore = await feeOnTransferToken.balanceOf(
        await collateralManager.getAddress()
      );

      // Lock collateral (should use actual received amount)
      await collateralManager.connect(authorizedCaller).lockCollateralWithTransfer(
        user1.address,
        await feeOnTransferToken.getAddress(),
        amount
      );

      const contractBalanceAfter = await feeOnTransferToken.balanceOf(
        await collateralManager.getAddress()
      );

      const actualReceived = contractBalanceAfter - contractBalanceBefore;

      // Should record actual received amount, not requested amount
      const userBalance = await collateralManager.getUserCollateral(
        user1.address,
        await feeOnTransferToken.getAddress()
      );

      expect(userBalance).to.equal(actualReceived);
    });

    it("Should revert if no tokens received", async function () {
      const amount = ethers.parseEther("100");

      // Don't approve tokens - transfer will fail
      await expect(
        collateralManager.connect(authorizedCaller).lockCollateralWithTransfer(
          user1.address,
          await mockERC20.getAddress(),
          amount
        )
      ).to.be.reverted;
    });

    it("Should revert if received amount is less than requested", async function () {
      const amount = ethers.parseEther("100");

      // Approve less than requested
      await mockERC20.connect(authorizedCaller).approve(
        await collateralManager.getAddress(),
        ethers.parseEther("50")
      );

      await expect(
        collateralManager.connect(authorizedCaller).lockCollateralWithTransfer(
          user1.address,
          await mockERC20.getAddress(),
          amount
        )
      ).to.be.reverted;
    });
  });

  describe("C-1.2: Phantom Collateral Attack Prevention", function () {
    it("Should prevent locking collateral without token transfer", async function () {
      const amount = ethers.parseEther("100");

      // Attempt to lock without approving tokens
      await expect(
        collateralManager.connect(authorizedCaller).lockCollateralWithTransfer(
          attacker.address,
          await mockERC20.getAddress(),
          amount
        )
      ).to.be.reverted;

      // Verify no collateral was recorded
      const attackerBalance = await collateralManager.getUserCollateral(
        attacker.address,
        await mockERC20.getAddress()
      );
      expect(attackerBalance).to.equal(0);
    });

    it("Should prevent double-counting with legacy lockCollateral", async function () {
      const amount = ethers.parseEther("100");

      // Using legacy function without actual transfer should still work
      // (but caller is responsible for transferring first)
      const lockId = await collateralManager.connect(authorizedCaller).lockCollateral.staticCall(
        user1.address,
        await mockERC20.getAddress(),
        amount
      );

      await collateralManager.connect(authorizedCaller).lockCollateral(
        user1.address,
        await mockERC20.getAddress(),
        amount
      );

      // Balance is recorded, but contract doesn't have tokens
      const userBalance = await collateralManager.getUserCollateral(
        user1.address,
        await mockERC20.getAddress()
      );
      expect(userBalance).to.equal(amount);

      // Attempting to release should fail due to insufficient contract balance
      await expect(
        collateralManager.connect(authorizedCaller).releaseCollateral(
          user1.address,
          await mockERC20.getAddress(),
          amount
        )
      ).to.be.reverted; // SafeERC20 will revert on insufficient balance
    });
  });

  describe("C-1.3: Actual vs Requested Amount Tracking", function () {
    it("Should track actual received amount for fee-on-transfer tokens", async function () {
      const requestedAmount = ethers.parseEther("100");

      await feeOnTransferToken.connect(authorizedCaller).approve(
        await collateralManager.getAddress(),
        requestedAmount
      );

      const balanceBefore = await feeOnTransferToken.balanceOf(
        await collateralManager.getAddress()
      );

      await collateralManager.connect(authorizedCaller).lockCollateralWithTransfer(
        user1.address,
        await feeOnTransferToken.getAddress(),
        requestedAmount
      );

      const balanceAfter = await feeOnTransferToken.balanceOf(
        await collateralManager.getAddress()
      );

      const actualReceived = balanceAfter - balanceBefore;

      // User balance should match actual received, not requested
      const userBalance = await collateralManager.getUserCollateral(
        user1.address,
        await feeOnTransferToken.getAddress()
      );

      expect(userBalance).to.equal(actualReceived);
      expect(actualReceived).to.be.lte(requestedAmount);
    });

    it("Should emit correct amount in CollateralLocked event", async function () {
      const amount = ethers.parseEther("100");

      await mockERC20.connect(authorizedCaller).approve(
        await collateralManager.getAddress(),
        amount
      );

      await expect(
        collateralManager.connect(authorizedCaller).lockCollateralWithTransfer(
          user1.address,
          await mockERC20.getAddress(),
          amount
        )
      ).to.emit(collateralManager, "CollateralLocked")
        .withArgs(
          user1.address,
          await mockERC20.getAddress(),
          amount,
          1 // lockId
        );
    });
  });

  describe("C-1.4: Input Validation", function () {
    it("Should reject zero amount", async function () {
      await expect(
        collateralManager.connect(authorizedCaller).lockCollateralWithTransfer(
          user1.address,
          await mockERC20.getAddress(),
          0
        )
      ).to.be.revertedWith("Amount must be positive");
    });

    it("Should reject invalid user address", async function () {
      await expect(
        collateralManager.connect(authorizedCaller).lockCollateralWithTransfer(
          ethers.ZeroAddress,
          await mockERC20.getAddress(),
          ethers.parseEther("100")
        )
      ).to.be.revertedWith("Invalid user address");
    });

    it("Should reject unsupported asset", async function () {
      const UnsupportedToken = await ethers.getContractFactory("MockERC20");
      const unsupportedToken = await UnsupportedToken.deploy("Unsupported", "UNS", 18);
      await unsupportedToken.waitForDeployment();

      await expect(
        collateralManager.connect(authorizedCaller).lockCollateralWithTransfer(
          user1.address,
          await unsupportedToken.getAddress(),
          ethers.parseEther("100")
        )
      ).to.be.revertedWith("Asset not supported");
    });
  });

  describe("C-1.5: Access Control", function () {
    it("Should only allow authorized callers to lock collateral", async function () {
      const amount = ethers.parseEther("100");

      await mockERC20.connect(attacker).approve(
        await collateralManager.getAddress(),
        amount
      );

      await expect(
        collateralManager.connect(attacker).lockCollateralWithTransfer(
          user1.address,
          await mockERC20.getAddress(),
          amount
        )
      ).to.be.revertedWith("Not authorized");
    });

    it("Should allow owner to lock collateral", async function () {
      const amount = ethers.parseEther("100");

      await mockERC20.connect(owner).approve(
        await collateralManager.getAddress(),
        amount
      );

      await expect(
        collateralManager.connect(owner).lockCollateralWithTransfer(
          user1.address,
          await mockERC20.getAddress(),
          amount
        )
      ).to.not.be.reverted;
    });
  });

  describe("C-1.6: Reentrancy Protection", function () {
    it("Should be protected against reentrancy during lock", async function () {
      // The nonReentrant modifier should prevent reentrancy
      const amount = ethers.parseEther("100");

      await mockERC20.connect(authorizedCaller).approve(
        await collateralManager.getAddress(),
        amount
      );

      // First call
      await collateralManager.connect(authorizedCaller).lockCollateralWithTransfer(
        user1.address,
        await mockERC20.getAddress(),
        amount
      );

      // Verify state is consistent
      const userBalance = await collateralManager.getUserCollateral(
        user1.address,
        await mockERC20.getAddress()
      );
      expect(userBalance).to.equal(amount);
    });
  });
});
