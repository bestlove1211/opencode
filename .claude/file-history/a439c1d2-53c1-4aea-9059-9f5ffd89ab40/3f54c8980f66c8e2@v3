const { expect } = require("chai");
const { ethers, upgrades } = require("hardhat");

describe("MultiAssetCollateralManager", function () {
  let multiAssetCollateral, priceOracle;
  let owner, user1, manager, liquidator;
  let mockUSDC, mockWETH, mockWBTC;

  const MANAGER_ROLE = ethers.keccak256(ethers.toUtf8Bytes("MANAGER_ROLE"));
  const LIQUIDATOR_ROLE = ethers.keccak256(ethers.toUtf8Bytes("LIQUIDATOR_ROLE"));

  beforeEach(async function () {
    [owner, user1, manager, liquidator, mockChainlinkFeed] = await ethers.getSigners();

    // Deploy mock tokens
    const MockERC20 = await ethers.getContractFactory("MockERC20");
    mockUSDC = await MockERC20.deploy("Mock USDC", "USDC", 6);
    mockWETH = await MockERC20.deploy("Mock WETH", "WETH", 18);
    mockWBTC = await MockERC20.deploy("Mock WBTC", "WBTC", 8);

    await mockUSDC.waitForDeployment();
    await mockWETH.waitForDeployment();
    await mockWBTC.waitForDeployment();

    // Use mock address for Price Oracle (Multi-Asset Collateral Manager might not directly use it)
    priceOracle = { address: mockChainlinkFeed.address };

    // Deploy Multi-Asset Collateral Manager
    const MultiAssetCollateralManager = await ethers.getContractFactory(
      "MultiAssetCollateralManager"
    );
    multiAssetCollateral = await upgrades.deployProxy(
      MultiAssetCollateralManager,
      [priceOracle.address],
      { initializer: "initialize", kind: "uups" }
    );
    await multiAssetCollateral.waitForDeployment();

    // Grant roles
    await multiAssetCollateral.grantRole(MANAGER_ROLE, manager.address);
    await multiAssetCollateral.grantRole(LIQUIDATOR_ROLE, liquidator.address);

    // Configure assets
    // Signature: configureAsset(asset, isSupported, liquidationThreshold, minCollateralRatio, liquidationBonus, maxAllocation, decimals)
    await multiAssetCollateral.configureAsset(
      await mockWETH.getAddress(),
      true, // isSupported
      8000, // liquidationThreshold (80% in basis points)
      15000, // minCollateralRatio (150% in basis points)
      500, // liquidationBonus (5% in basis points)
      10000, // maxAllocation (100% in basis points)
      18 // decimals
    );

    await multiAssetCollateral.configureAsset(
      await mockWBTC.getAddress(),
      true, // isSupported
      8000, // liquidationThreshold (80%)
      15000, // minCollateralRatio (150%)
      500, // liquidationBonus (5%)
      10000, // maxAllocation (100%)
      8 // decimals
    );

    await multiAssetCollateral.configureAsset(
      await mockUSDC.getAddress(),
      true, // isSupported
      9500, // liquidationThreshold (95%)
      11000, // minCollateralRatio (110%)
      300, // liquidationBonus (3%)
      10000, // maxAllocation (100%)
      6 // decimals
    );

    // Mint tokens to user
    await mockWETH.mint(user1.address, ethers.parseEther("10"));
    await mockWBTC.mint(user1.address, ethers.parseUnits("0.5", 8));
    await mockUSDC.mint(user1.address, ethers.parseUnits("10000", 6));
  });

  describe("Deployment", function () {
    it("Should set correct price oracle", async function () {
      expect(await multiAssetCollateral.priceOracle()).to.equal(
        priceOracle.address
      );
    });

    it("Should grant admin role to deployer", async function () {
      const DEFAULT_ADMIN_ROLE = ethers.ZeroHash;
      expect(
        await multiAssetCollateral.hasRole(DEFAULT_ADMIN_ROLE, owner.address)
      ).to.be.true;
    });

    it("Should start with basket ID 1", async function () {
      expect(await multiAssetCollateral.nextBasketId()).to.equal(1);
    });
  });

  describe("Basket Creation", function () {
    it("Should create a new basket", async function () {
      await expect(
        multiAssetCollateral.connect(manager).createBasket(
          user1.address,
          await mockUSDC.getAddress(),
          ethers.parseUnits("10000", 6)
        )
      )
        .to.emit(multiAssetCollateral, "BasketCreated")
        .withArgs(1, user1.address, await mockUSDC.getAddress(), ethers.parseUnits("10000", 6));
    });

    it("Should increment basket ID", async function () {
      await multiAssetCollateral.connect(manager).createBasket(
        user1.address,
        await mockUSDC.getAddress(),
        ethers.parseUnits("10000", 6)
      );

      expect(await multiAssetCollateral.nextBasketId()).to.equal(2);
    });

    it("Should track user baskets", async function () {
      await multiAssetCollateral.connect(manager).createBasket(
        user1.address,
        await mockUSDC.getAddress(),
        ethers.parseUnits("10000", 6)
      );

      const userBaskets = await multiAssetCollateral.getUserBaskets(user1.address);
      expect(userBaskets.length).to.equal(1);
      expect(userBaskets[0]).to.equal(1);
    });
  });

  describe("Adding Collateral", function () {
    let basketId;

    beforeEach(async function () {
      const tx = await multiAssetCollateral.connect(manager).createBasket(
        user1.address,
        await mockUSDC.getAddress(),
        ethers.parseUnits("10000", 6)
      );
      const receipt = await tx.wait();
      basketId = 1;
    });

    it("Should add single collateral asset", async function () {
      const amount = ethers.parseEther("1");
      await mockWETH.connect(user1).approve(
        await multiAssetCollateral.getAddress(),
        amount
      );

      await expect(
        multiAssetCollateral.connect(user1).addCollateral(
          basketId,
          await mockWETH.getAddress(),
          amount
        )
      ).to.emit(multiAssetCollateral, "CollateralAdded");
    });

    it("Should add multiple collateral assets in batch", async function () {
      const assets = [
        await mockWETH.getAddress(),
        await mockWBTC.getAddress(),
        await mockUSDC.getAddress()
      ];
      const amounts = [
        ethers.parseEther("1"),
        ethers.parseUnits("0.1", 8),
        ethers.parseUnits("1000", 6)
      ];

      for (let i = 0; i < assets.length; i++) {
        const token = await ethers.getContractAt("MockERC20", assets[i]);
        await token.connect(user1).approve(
          await multiAssetCollateral.getAddress(),
          amounts[i]
        );
      }

      await multiAssetCollateral.connect(user1).batchAddCollateral(
        basketId,
        assets,
        amounts
      );

      const basketAssets = await multiAssetCollateral.getBasketAssets(basketId);
      expect(basketAssets.length).to.equal(3);
    });

    it("Should enforce max assets per basket", async function () {
      const MAX_ASSETS = 10;

      // This test would need to add 10+ assets which is expensive
      // Simplified version: just check the constant exists
      expect(await multiAssetCollateral.MAX_ASSETS_PER_BASKET()).to.equal(MAX_ASSETS);
    });

    it("Should reject adding below minimum amount", async function () {
      const tinyAmount = ethers.parseEther("0.001"); // Below 0.01 minimum
      await mockWETH.connect(user1).approve(
        await multiAssetCollateral.getAddress(),
        tinyAmount
      );

      await expect(
        multiAssetCollateral.connect(user1).addCollateral(
          basketId,
          await mockWETH.getAddress(),
          tinyAmount
        )
      ).to.be.revertedWith("Below minimum amount");
    });
  });

  describe("Basket Value Calculation", function () {
    let basketId;

    beforeEach(async function () {
      await multiAssetCollateral.connect(manager).createBasket(
        user1.address,
        await mockUSDC.getAddress(),
        ethers.parseUnits("10000", 6)
      );
      basketId = 1;

      // Add collateral
      const amount = ethers.parseEther("1"); // 1 ETH = $2000
      await mockWETH.connect(user1).approve(
        await multiAssetCollateral.getAddress(),
        amount
      );
      await multiAssetCollateral.connect(user1).addCollateral(
        basketId,
        await mockWETH.getAddress(),
        amount
      );
    });

    it("Should calculate basket value correctly", async function () {
      const value = await multiAssetCollateral.getBasketValue(basketId);
      // 1 ETH * $2000 = $2000 (in 18 decimals)
      expect(value).to.be.closeTo(ethers.parseEther("2000"), ethers.parseEther("1"));
    });

    it("Should update basket total value", async function () {
      const basket = await multiAssetCollateral.getBasketDetails(basketId);
      expect(basket.totalValueUSD).to.be.gt(0);
    });
  });

  describe("Health Factor", function () {
    let basketId;

    beforeEach(async function () {
      await multiAssetCollateral.connect(manager).createBasket(
        user1.address,
        await mockUSDC.getAddress(),
        ethers.parseUnits("10000", 6) // $10,000 loan
      );
      basketId = 1;

      // Add $15,000 worth of collateral (1.5x)
      const ethAmount = ethers.parseEther("7.5"); // 7.5 ETH * $2000 = $15,000
      await mockWETH.connect(user1).approve(
        await multiAssetCollateral.getAddress(),
        ethAmount
      );
      await multiAssetCollateral.connect(user1).addCollateral(
        basketId,
        await mockWETH.getAddress(),
        ethAmount
      );
    });

    it("Should calculate health factor", async function () {
      const healthFactor = await multiAssetCollateral.calculateHealthFactor(basketId);
      // Health factor should be > 1 (150% collateralization)
      expect(healthFactor).to.be.gt(ethers.parseEther("1"));
    });

    it("Should check if basket is healthy", async function () {
      const loanValueUSD = ethers.parseEther("10000");
      const isHealthy = await multiAssetCollateral.isBasketHealthy(basketId, loanValueUSD);
      expect(isHealthy).to.be.true;
    });
  });

  describe("Diversification Scoring", function () {
    let basketId;

    beforeEach(async function () {
      await multiAssetCollateral.connect(manager).createBasket(
        user1.address,
        await mockUSDC.getAddress(),
        ethers.parseUnits("10000", 6)
      );
      basketId = 1;
    });

    it("Should return 0 for empty basket", async function () {
      const score = await multiAssetCollateral.getBasketDiversification(basketId);
      expect(score).to.equal(0);
    });

    it("Should return low score for single asset", async function () {
      await mockWETH.connect(user1).approve(
        await multiAssetCollateral.getAddress(),
        ethers.parseEther("1")
      );
      await multiAssetCollateral.connect(user1).addCollateral(
        basketId,
        await mockWETH.getAddress(),
        ethers.parseEther("1")
      );

      const score = await multiAssetCollateral.getBasketDiversification(basketId);
      expect(score).to.be.lt(5000); // Less than 50%
    });

    it("Should return higher score for diversified basket", async function () {
      const assets = [
        await mockWETH.getAddress(),
        await mockWBTC.getAddress(),
        await mockUSDC.getAddress()
      ];
      const amounts = [
        ethers.parseEther("1"),
        ethers.parseUnits("0.05", 8),
        ethers.parseUnits("2000", 6)
      ];

      for (let i = 0; i < assets.length; i++) {
        const token = await ethers.getContractAt("MockERC20", assets[i]);
        await token.connect(user1).approve(
          await multiAssetCollateral.getAddress(),
          amounts[i]
        );
      }

      await multiAssetCollateral.connect(user1).batchAddCollateral(
        basketId,
        assets,
        amounts
      );

      const score = await multiAssetCollateral.getBasketDiversification(basketId);
      expect(score).to.be.gt(0);
    });
  });

  describe("Liquidation", function () {
    let basketId;

    beforeEach(async function () {
      await multiAssetCollateral.connect(manager).createBasket(
        user1.address,
        await mockUSDC.getAddress(),
        ethers.parseUnits("10000", 6)
      );
      basketId = 1;

      await mockWETH.connect(user1).approve(
        await multiAssetCollateral.getAddress(),
        ethers.parseEther("1")
      );
      await multiAssetCollateral.connect(user1).addCollateral(
        basketId,
        await mockWETH.getAddress(),
        ethers.parseEther("1")
      );
    });

    it("Should liquidate entire basket", async function () {
      await expect(
        multiAssetCollateral.connect(liquidator).liquidateBasket(
          basketId,
          liquidator.address
        )
      ).to.emit(multiAssetCollateral, "BasketLiquidated");
    });

    it("Should transfer assets to liquidator", async function () {
      const balanceBefore = await mockWETH.balanceOf(liquidator.address);

      await multiAssetCollateral.connect(liquidator).liquidateBasket(
        basketId,
        liquidator.address
      );

      const balanceAfter = await mockWETH.balanceOf(liquidator.address);
      expect(balanceAfter).to.be.gt(balanceBefore);
    });
  });

  describe("Access Control", function () {
    it("Should restrict basket creation to managers", async function () {
      await expect(
        multiAssetCollateral.connect(user1).createBasket(
          user1.address,
          await mockUSDC.getAddress(),
          ethers.parseUnits("10000", 6)
        )
      ).to.be.reverted;
    });

    it("Should restrict liquidation to liquidators", async function () {
      await multiAssetCollateral.connect(manager).createBasket(
        user1.address,
        await mockUSDC.getAddress(),
        ethers.parseUnits("10000", 6)
      );

      await expect(
        multiAssetCollateral.connect(user1).liquidateBasket(1, user1.address)
      ).to.be.reverted;
    });
  });
});
